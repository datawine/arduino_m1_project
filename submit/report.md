# 智能卡大作业报告

#### 沈俊贤 计52 2015011258

#### 周京汉 计52 2015011245

#### 李睿燮 计55 2015080062

## 一、背景与问题分析

### 1、背景描述

TODO: 沈俊贤

### 2、重点难点

TODO: 沈俊贤

## 二、实验原理与方案

### 1、实验设计与问题解决

#### M1卡压力读取：

TODO: 沈俊贤

#### M1卡内加密：

TODO：李睿燮

### 2、实验实现：

#### M1卡读写：

TODO：李睿燮

#### 底层读卡接口：

TODO: 沈俊贤

#### 服务器：

我们我服务器是用django框架搭建的。在服务器端，我们主要是拥有两大功能：第一个是能够完成注册中心的功能；可以创建新的卡片信息以及可以为旧用户进行注册，即延长有效期；与注销卡片信息。第二个是服务器功能，可以用数据库存储所有用户的信息。

第一部分，在注册中心功能这里，我们应用了之前来自M1卡读写的接口，在调用之下可以直接对指定的block进行读和写的操作。在进行创建的时候，可以在服务器中访问`/testdb`，来进行创建和对于卡片的读写；在进行注销的时候，可以访问`/clear`来进行消除。

第二部分，在服务器中，每一次对应的读取卡操作，或者外面传来的对卡操作的请求，在通过判断之后都会对其中数据库的信息产生修改。在服务器的数据库之中，外面存储了一下信息：

* 姓名 -- name
* 学号 -- idnumber
* 院系 -- department
* 身份 -- identifier
* 性别 -- sex
* 有效期 -- validdate
* 余额 -- money

服务器应用了django原生的sqlite3数据库，代码结构使用了软工当中的分层结构，在最底层为中支持对数据库进行多种多样的读写操作；并且在上面一层增加了各种判定，保证输入的操作请求和返回的数据全部是合法，符合我们格式规定的数据，增加了安全性。再上面一层为将数据库与Arduino读卡接口连接的程序，最上面一层为支持url操作的代码。

另外，在安全方面，我们后面的设想是加入一个新的table表项在数据库之中，这个表项为由卡片的UID与系统中的16为key等信息进行异或操作得到的标识码，来增加对于卡的识别度，但是由于时间原因没有完成。

#### 客户端：

客户端我们依然使用的是python3进行书写，其代码结构仍然使用了分层机构，包括和Arduino进行串口交流，调用交流接口，对客户端输入进行解析和对于接口的调用。

在客户端中每次启动的时候，系统都会自动向服务器端请求全部学生当前的信息，并存储起来，同时自动生成（或者）读取一份门禁信息。

在客户端，我们总共有三个模块：注册中心，零钱包，门禁。

首先注册中心这边的功能有：

* 创建新卡
* 延长旧卡有效期（注册）
* 获得卡片信息（丢卡做新的）
* 注销旧卡：分为只删除卡片和同时删除数据库中的信息
* 添加门禁信息
* 删除门禁信息

其功能完全覆盖了服务器端，甚至还多出来一些。其中在门禁这一块，我们的设定为：每次判断门禁，都会先读取卡内的基本信息，然后在本地进行学号判断，如果本地添加了该学号的信息，则可以进入下一环节；随后判断服务器状态，如果服务器可以连接，便联网询问服务器其信息时候有效，否则则在本地对其信息进行判断。

随后的是零钱包功能有：

* 查询余额
* 圈存
* 消费
* 查询消费记录

其为四个基本功能，在每次开启零钱包的时候就先读取其基本信息，获得余额和消费记录的显示。并且在每次花钱之后在本地更新余额等信息。

最后是门禁部分，本部分包括：

* 联网门禁
* 断网门禁

本部分由于界面并不是十分需要，因此没有写图形界面，是用shell进行启动和信息返回的。并且，其中的联网和断网是在每次进行门禁的时候进行判断的，只有在发现服务器不可用的时候才会进入相对不安全一点的断网门禁。

#### 客户端界面：

TODO:李睿燮

## 三、实验结果与结论

### 1、客户端shell模式测试

由于其他的测试基本都在图形界面当中，客户端shell的主要测试部分为门禁。在实验展示的视频当中的5，6两部分可以看到这一部分的测试。测试结果十分流畅，可以自动判断服务器是否可用，并会正确的返回门禁是否通过。

其余部分的功能实际上也都可以通过shell进行操作，实际实验当中，由于没有Electron的通信延迟，shell操作速度反而更快，更加流畅！

### 2、客户端界面测试

TODO：周京汉

### 3、服务器创建注册

TODO：周京汉

### 4、读卡遇见的问题与解决

TODO: 沈俊贤

## 四、思考与总结

这个各写一点吧，然后拼起来